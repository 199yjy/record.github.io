<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>yjieyan的私人博客</title><link>https://199yjy.github.io/record.github.io</link><description>记录</description><copyright>yjieyan的私人博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/35625289?v=4</url><title>avatar</title><link>https://199yjy.github.io/record.github.io</link></image><lastBuildDate>Wed, 15 Oct 2025 15:07:57 +0000</lastBuildDate><managingEditor>yjieyan的私人博客</managingEditor><ttl>60</ttl><webMaster>yjieyan的私人博客</webMaster><item><title>【Vue】Vue Diff原理</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90Vue%E3%80%91Vue%20Diff-yuan-li.html</link><description>## 一、Diff算法基础概念

### 1.1 什么是Diff算法
Diff算法是计算两个虚拟DOM树差异的算法，用于最小化DOM操作，提升渲染性能。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90Vue%E3%80%91Vue%20Diff-yuan-li.html</guid><pubDate>Wed, 15 Oct 2025 15:07:24 +0000</pubDate></item><item><title>【Vue】Vue2源码解析</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90Vue%E3%80%91Vue2-yuan-ma-jie-xi.html</link><description>
## 前言

Vue 作为一款渐进式 JavaScript 框架，其核心原理包括响应式系统、虚拟 DOM、模板编译和组件系统等。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90Vue%E3%80%91Vue2-yuan-ma-jie-xi.html</guid><pubDate>Wed, 15 Oct 2025 14:24:07 +0000</pubDate></item><item><title>【vue】vue-router原理</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90vue%E3%80%91vue-router-yuan-li.html</link><description>

## 路由基础

* 路由作用：根据不同的路径映射到不同的视图。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90vue%E3%80%91vue-router-yuan-li.html</guid><pubDate>Tue, 14 Oct 2025 13:25:32 +0000</pubDate></item><item><title>【工程化】从零到一搭建 Vue3 单页面应用2</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90-gong-cheng-hua-%E3%80%91-cong-ling-dao-yi-da-jian-%20Vue3%20-dan-ye-mian-ying-yong-2.html</link><description>## 实现前端自动化部署

实现思路：在`git push`命令设置一个钩子函数，即`/.husky/pre-push`，获取当前分支，依据当前分支执行对应的`npm 脚本`，先进行项目打包构建，再用`ftp-deploy`库推送打包后的文件到指定的服务器，最后才将项目上传到远程仓库

1. 利用`ftp-deploy`库，实现上传函数

   - `/deploy/index.ts`——上传函数

     ```ts
     const FtpDeploy = require('ftp-deploy');
     const ftpDeploy = new FtpDeploy();
     const DeployConfig = require('./config.ts')
     
     const config = DeployConfig.getFtpDeployConfig()
     
     ftpDeploy
       .deploy(config)
       .then((res) =&gt; console.log('finished:', res))
       .catch((err) =&gt; console.log(err));
     ```

   - `/deploy/config.ts`——上传配置

     ```ts
     const deployConfig = require('./serverConfig.ts')
     
     const getNODE_ENV = function() {
       const script = process.env.npm_lifecycle_script;
       const reg = new RegExp('NODE_ENV=([a-z_\\d]+)');
       const result = reg.exec(script);
       return result[1]
     }
     
     module.exports.getFtpDeployConfig = function getFtpDeployConfig() {
       return {
         user: deployConfig.user,                    // 服务器登录账号
         password: deployConfig.password,            // 服务器密码
         host: deployConfig.host,                    // 服务器地址
         port: deployConfig.port.get(getNODE_ENV()), // ftp的服务器端口
         localRoot: deployConfig.localRoot,          // 上传的文件
         remoteRoot: '',                             // 远程服务器文件存储路径
         include: ['.*'],                            // 这将上传除了点文件之外的所有文件
         // 排除sourcemaps和node_modules中的所有文件
         exclude: [
             'dist/**/*.map',
             'node_modules/**',
             'node_modules/**/.*',
             '.git/**',
         ],
         deleteRemote: false,                         // 如果为true，则在上传前删除目的地的所有现有文件
         forcePasv: true,                             // 主动模式/被动模式
         sftp: false,                                 // 使用 sftp协议 或 ftp协议
       }
     }
     ```

   - `/deploy/serverConfig.ts`——个人服务器配置，不上传到远程仓库，保障个人服务器安全

     ```ts
     module.exports = {
       user: 'user',
       password: 'password',
       host: 'ftp.someserver.com',
       port: new Map([
         ['test', 8080],
         ['production', 80]
       ]),
       localRoot: __dirname + '/dist',
     }
     ```

2. 设置`npm`脚本命令

   - 安装`cross-env`

     ```shell
     npm i cross-env -D
     ```

   - 修改`package.json`

     ```json
     {
       'scripts': {
         'deploy:test': 'cross-env NODE_ENV=test run-p build &amp;&amp; node ./deploy/index.ts',
         'deploy:prod': 'cross-env NODE_ENV=production run-p build &amp;&amp; node ./deploy/index.ts',
       },
     }
     ```

3. 实现`git-push`钩子函数——`/.husky/pre-push`

   ```shell
   #!/bin/sh
   . '$(dirname '$0')/_/husky.sh'
   
   # 代码推送前依据当前分支进行打包构建并上传（仅对 master 分支 和 test 分支进行构建）
   function current_branch() {
     branch=''
     testBranch='test'
     masterBranch='master'
     cd $PWD
     if [ -d '.git' ]; then
       output=`sh -c 'git branch --no-color 2&gt; /dev/null' | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/' -e 's/\//\_/g'`
       if [ '$output' ]; then
         branch='${output}'
       fi
     fi
   
     if [ $branch == $testBranch ]
     then
       echo '自动构建并上传 test 分支代码'
       npm run deploy:test
     elif [ $branch == $masterBranch ]
     then
       echo '自动构建并上传 master 分支代码'
       npm run deploy:prod
     fi
   }
   
   current_branch
   ```

# 框架配置管理

## 项目`TypeScript`配置 `tsconfig.ts`

```js
{
  'compileOnSave': true, //设置保存文件的时候自动编译
  'extends': '@vue/tsconfig/tsconfig.web.json', //引入其他配置文件，继承配置
  'exclude': ['node_modules', 'dist'], //指定编译器需要排除的文件或文件夹
  'include': [
    //指定编译需要编译的文件或目录
    'src/**/*.ts',
    'src/**/*.d.ts',
    'src/**/*.vue',
    'types/**/*.d.ts',
    'types/**/*.ts',
    'build/**/*.ts',
    'build/**/*.d.ts',
    'vite.config.*'
  ],
  'compilerOptions': {
    //配置编译选项
    'diagnostics': true, // 打印诊断信息
    'removeComments': true, //移除代码中注释
    'strictNullChecks': true, //开启null、undefined检测
    'baseUrl': '.', // 解析非相对模块的基地址，默认是当前目录
    'target': 'ES2015', // 目标语言的版本
    'moduleResolution': 'node', // 模块解析策略，ts默认用node的解析策略，即相对的方式导入
    'allowJs': false, // 允许编译器编译JS，JSX文件
    'checkJs': false, // 允许在JS文件中报错，通常与allowJS一起使用
    'sourceMap': true, // 生成目标文件的sourceMap文件
    'strict': true, // 开启所有严格的类型检查
    'noUnusedLocals': true, // 检查只声明、未使用的局部变量(只提示不报错)
    'noUnusedParameters': true, // 检查未使用的函数参数(只提示不报错)
    'esModuleInterop': true, // 允许export=导出，由import from 导入
    'paths': {
      // 路径映射，相对于baseUrl
      '@/*': ['./src/*'],
      '#/*': ['./types/*'],
      '$locale': ['./src/locales/setupLocale.ts'],
      '$store/*': ['./src/store/modules/*'],
    },
    'suppressImplicitAnyIndexErrors': true,
    'jsx': 'preserve',
    'types': ['node', 'vite/client']  //默认所有可见的”@types“包会在编译过程中被包含进来。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90-gong-cheng-hua-%E3%80%91-cong-ling-dao-yi-da-jian-%20Vue3%20-dan-ye-mian-ying-yong-2.html</guid><pubDate>Tue, 14 Oct 2025 08:20:44 +0000</pubDate></item><item><title>【webpack】webpack工作原理</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90webpack%E3%80%91webpack-gong-zuo-yuan-li.html</link><description>Webpack的编译过程就像一条精心设计的流水线，把我们的源代码一步步转化为最终可运行的代码。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90webpack%E3%80%91webpack-gong-zuo-yuan-li.html</guid><pubDate>Mon, 13 Oct 2025 14:38:14 +0000</pubDate></item><item><title>【JS】防抖、节流</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90JS%E3%80%91-fang-dou-%E3%80%81-jie-liu.html</link><description>防抖、节流都是用来控制高频率触发事件的执行次数的，但它们的适用场景和核心思想不同。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90JS%E3%80%91-fang-dou-%E3%80%81-jie-liu.html</guid><pubDate>Mon, 13 Oct 2025 00:41:54 +0000</pubDate></item><item><title>【工程化】从零到一搭建 Vue3 单页面应用1</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90-gong-cheng-hua-%E3%80%91-cong-ling-dao-yi-da-jian-%20Vue3%20-dan-ye-mian-ying-yong-1.html</link><description>| 插件 | 功能 | 
|-------|-------|
| vue3 |  | 
| ts |  |
| pinia | 状态管理 |
| vue-router |  |
| vue-i18n |  |
| element-plus | UI框架 |
| axios |  |
| eslint | 规范 |
| less | css处理器 |
| commitlint | git提交规范|
| husky | git钩子触发器 |

## 初始化框架
### 安裝vue
```js 
npm init vue@latest
```
### 初始化
```js vite.config.ts
import { fileURLToPath, URL } from 'node:url';

import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
// 如果编辑器提示 path 模块找不到，则可以安装一下 @types/node -&gt; npm i @types/node -D
import path from 'path';
// https://vitejs.dev/config/
export default defineConfig({
  // 需要用到的插件数组
  plugins: [vue()],
  // 解析
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url)),
    },
  },
  // 开发或生产环境服务的公共基础路径
  base: './',
  // 服务器选项
  server: {
    // 指定开发服务器端口
    port: 4000,
    // 在开发服务器启动时自动在浏览器中打开应用程序
    open: true,
    // 为开发服务器配置 CORS
    cors: true,
  },
});
```
### 初始化目录
```js
├─ .vscode
│  └─ extensions.json
├─ bulid			# 打包配置模块
├─ public			# 公共资源模块
│  └─ favicon.ico
├─ src
│  ├─ api			# 接口管理模块
│  ├─ assets		# 静态资源模块
│  │  └─ logo.png
│  ├─ common		# 自定义通用模块
│  ├─ components	# 公共组件模块
│  │  └─ HelloWorld.vue
│  ├─ layouts		# 公共自定义布局
│  ├─ router		# 路由
│  ├─ stores		# pinia状态库
│  ├─ style			# 样式资源模块
│  ├─ utils			# 公共方法模块
│  ├─ views			# 视图模块
│  ├─ App.vue
│  ├─ env.d.ts
│  └─ main.ts		# 入口文件
├─ tests
├─ types			# 声明文件
├─ .gitignore
├─ index.html
├─ package-lock.json
├─ package.json
├─ README.md
├─ tsconfig.json
└─ vite.config.ts

```
## 初始化路由
### 安装路由
```js
npm install vue-router
```
### 配置路由文件
### 挂载路由
```js
import { createApp } from 'vue';
import App from './App.vue';
import router from '@/router/index';

const app = createApp(App);

app.use(router);

app.mount('#app');
```
## 初始化状态
### 安装pinia
```js
npm install pinia

```
### 配置状态仓库
```js index.ts
import type { App } from 'vue';
import { createPinia } from 'pinia';

const store = createPinia();

export function setupStore(app: App&lt;Element&gt;) {
  app.use(store);
}

export { store };

```
```js userStore.ts
import { store } from '@/store';
import { defineStore } from 'pinia';

export const useUserStore = defineStore({
  id: 'userStore',
  state: () =&gt; ({}),
  getters: {},
  actions: {},  
});

export function useUserStoreHook() {
  return useUserStore(store);
}
```
### 挂载
```js
import { createApp } from 'vue';
import App from './App.vue';
import { setupStore } from '@/store';

const app = createApp(App);

// 配置状态仓库
setupStore(app);

app.mount('#app');

```
## 集成element-plus组件库
### 安装
```js
npm install element-plus --save

```
### 选择导入方式
- 完全导入
```
import type { App } from 'vue';

/**
 * 完整导入 element-plus 组件
 * @param app {App}
 */
import ElementPlus from 'element-plus';
import 'element-plus/dist/index.css';
import '@/style/element-plus.css';
import Modal from '@/components/Dialog';

/**
 * 完整导入 element-plus 图标
 * @param app {App}
 */
import * as ElementPlusIconsVue from '@element-plus/icons-vue';

export default function fullLoadEl(app: App, params: Object) {
  app.use(ElementPlus, params);
  for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
    app.component(key, component);
  }
  Modal._context = app._context;
  return app;
}
```
- 按需导入
```js
import type { App } from 'vue';

/**
 * 按需导入 element-plus 组件
 * @param app {App}
 */
import 'element-plus/dist/index.css';
import { ElIcon, ElButton, ElInput, ElCheckbox } from 'element-plus';
import '@/style/element-plus.css';

/**
 * 按需导入 element-plus 图标
 * @param app {App}
 */
import { Edit, Tools, Location, Setting } from '@element-plus/icons-vue';

export default function loadOnDemandEl(app: App) {
  [ElButton, ElIcon, ElInput, ElCheckbox].forEach((v) =&gt; {
    app.use(v);
  });
  [Edit, Tools, Location, Setting].forEach((v) =&gt; {
    app.component(v.name, v);
  });
  return app;
}
```

### 加载
```js
import { createApp } from 'vue';
import App from './App.vue';
import fullLoadEl from '@/packages/element-plus/fullLoadEl ';

const app = createApp(App);

// 全局引入
fullLoadEl(app);

app.mount('#app');
```
## 集成axios
### 安装axios
```js
npm install axios
```
### 二次封装axios
参考vben-admin对axios的封装
调用封装的axios类VAxios，传自设参数和项目预设参数的合并对象为参数，生成VAxios实例对象
```js
import type { AxiosResponse } from 'axios';
import type { RequestOptions, Result } from './types/axios';
/*
  export type ErrorMessageMode = 'none' | 'modal' | 'message' | undefined;
  export type SuccessMessageMode = 'none' | 'message';

  export interface RequestOptions {
    // Format request parameter time
    formatDate?: boolean;
    // Whether to process the request result
    isTransformResponse?: boolean;
    // Whether to return native response headers
    // For example: use this attribute when you need to get the response headers
    isReturnNativeResponse?: boolean;
    // Error message prompt type
    errorMessageMode?: ErrorMessageMode;
    // Successful request message prompt
    successMessageMode?: SuccessMessageMode;
    // Whether to add a timestamp
    joinTime?: boolean;
    ignoreCancelToken?: boolean;
    // Whether to send token in header
    withToken?: boolean;
    // 请求重试机制
    retryRequest?: RetryRequest;
  }

  export interface Result&lt;T = any&gt; {
    code: number | string;
    type: 'success' | 'error' | 'warning';
    msg: string;
    data: T;
  }

  // multipart/form-data: upload file
  export interface UploadFileParams {
    // Other parameters
    data?: Recordable;
    // File parameter interface field name
    name?: string;
    // file name
    file: File | Blob;
    // file name
    filename?: string;
    [key: string]: any;
  }
*/
import type { AxiosTransform, CreateAxiosOptions } from '@/packages/http/axios/axiosTransform';
import axios from 'axios';
import { clone } from 'lodash-es';
import { VAxios } from '@/packages/http/axios/Axios';
import { checkStatus } from '@/packages/http/axios/checkStatus';
import { AxiosRetry } from '@/packages/http/axios/axiosRetry';
import { joinTimestamp, formatRequestDate } from '@/packages/http/axios/helper';
import { RequestEnum, ResultEnum, ContentTypeEnum } from '@/enums/httpEnum';
/*

  // @description: Request result set
  export enum ResultEnum {
    SUCCESS = 200,
    ERROR = -1,
    TIMEOUT = 401,
    TYPE = 'success',
  }

  // @description: request method
  export enum RequestEnum {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    DELETE = 'DELETE',
  }

  // @description:  contentType
  export enum ContentTypeEnum {
    // json
    JSON = 'application/json;charset=UTF-8',
    // form-data qs
    FORM_URLENCODED = 'application/x-www-form-urlencoded;charset=UTF-8',
    // form-data  upload
    FORM_DATA = 'multipart/form-data;charset=UTF-8',
  }
*/
import { deepMerge } from '@/utils';
/*
  export function deepMerge&lt;T = any&gt;(src: any = {}, target: any = {}): T {
    let key: string;
    for (key in target) {
      src[key] = isObject(src[key]) ? deepMerge(src[key], target[key]) : (src[key] = target[key]);
    }
    return src;
  }
*/
import { getAppEnvConfig } from '@/utils/env';
/* 
  // build/getConfigFileName.ts
  export const getConfigFileName = (env: Record&lt;string, any&gt;) =&gt; {
    return `__PRODUCTION__${env.VITE_GLOB_APP_SHORT_NAME || '__APP'}__CONF__`
      .toUpperCase()
      .replace(/\s/g, '');
  };

  export function getAppEnvConfig() {
    const ENV_NAME = getConfigFileName(import.meta.env);
      
    const ENV = (import.meta.env.DEV
      ? // Get the global configuration (the configuration will be extracted independently when packaging)
        (import.meta.env as unknown as GlobEnvConfig)
      : window[ENV_NAME as any]) as unknown as GlobEnvConfig;

    const { VITE_GLOB_API_URL } = ENV;

    return {
      VITE_GLOB_API_URL,
    };
 }
*/
import { removeToken，getToken } from '@/utils/token';
/*
  import Cookies from 'js-cookie';

  const TokenKey = 'Token';

  export function getToken() {
    return Cookies.get(TokenKey);
  }

  export function setToken(token: string) {
    return Cookies.set(TokenKey, token);
  }

  export function removeToken() {
    return Cookies.remove(TokenKey);
  }
*/
import { isString } from '@/utils/is';
/*
  const toString = Object.prototype.toString;

  export function is(val: unknown, type: string) {
    return toString.call(val) === `[object ${type}]`;
  }
  
  export function isString(val: unknown): val is string {
    return is(val, 'String');
  }
*/
import { useUserStoreWithOut } from '$store/user';
import { ElMessage, ElMessageBox } from 'element-plus';
import { s } from '$locale';

const { VITE_GLOB_API_URL } = getAppEnvConfig();

const transform: AxiosTransform = {
  /**
   * @description: 处理响应数据。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90-gong-cheng-hua-%E3%80%91-cong-ling-dao-yi-da-jian-%20Vue3%20-dan-ye-mian-ying-yong-1.html</guid><pubDate>Sun, 12 Oct 2025 15:40:41 +0000</pubDate></item><item><title>【登录鉴权】单点登录</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90-deng-lu-jian-quan-%E3%80%91-dan-dian-deng-lu.html</link><description>核心机制：本质是 “一处登录，处处通行”。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90-deng-lu-jian-quan-%E3%80%91-dan-dian-deng-lu.html</guid><pubDate>Sun, 12 Oct 2025 12:47:32 +0000</pubDate></item><item><title>【登录鉴权】常见的登录鉴权⽅式</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90-deng-lu-jian-quan-%E3%80%91-chang-jian-de-deng-lu-jian-quan-%E2%BD%85-shi.html</link><description>- 基于Session Cookie的鉴权
    - cookie: ⽤户在登录成功后，服务器会⽣成⼀个包含⽤户信息的Cookie，并返回给前端。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90-deng-lu-jian-quan-%E3%80%91-chang-jian-de-deng-lu-jian-quan-%E2%BD%85-shi.html</guid><pubDate>Sun, 12 Oct 2025 09:11:52 +0000</pubDate></item><item><title>【异步】手写Promise</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90-yi-bu-%E3%80%91-shou-xie-Promise.html</link><description># Promise

Promise特点：
- 执行了resolve，Promise状态会变成fulfilled
- 执行了reject，Promise状态会变成rejected
- Promise状态不可逆，第一次成功就永久为fulfilled，第一次失败就永远状态为rejected
- Promise中有throw的话，就相当于执行了reject
- then接收两个回调，一个是成功回调，一个是失败回调
- 当Promise状态为fulfilled执行成功回调，为rejected执行失败回调
- 如resolve或reject在定时器里，则定时器结束后再执行then
- then支持链式调用，下一次then执行受上一次then返回值的影响

思路：
- Promise的初始状态是pending，状态一旦变为fulfilled成功或者rejected失败，就不可更改
- 对resolve和reject绑定this：确保resolve和reject的this指向永远指向当前的MyPromise实例，防止随着函数执行环境的改变而改变
- 捕捉到错误直接执行reject
- 链式调用：
    - then接收两个回调(成功，失败)，当Promise状态为fulfilled执行成功回调，为rejected执行失败回调
    - 如resolve或reject在定时器里，则定时器结束后再执行then
        - 如果state=成功，执行成功的回调
        - 如果state=失败，执行失败的回调方法
        - 如果pending，暂时保存回调任务
    - then支持链式调用，下一次then执行受上一次then返回值的影响

```js
class MyPromise {
    constructor(executor) {
        // 初始化值
        this.initValue()
        // 初始化this指向
        this.initBind()
        try {
            // 执行传进来的函数
            executor(this.resolve, this.reject)
        } catch (e) {
            // 如果捕捉到错误直接执行reject
            this.reject(e)
        }
    }

    initBind() {
        // 初始化this
        this.resolve = this.resolve.bind(this)
        this.reject = this.reject.bind(this)
    }

    initValue() {
        // 初始化值
        this.PromiseResult = null // 终值
        this.PromiseState = 'pending' // 状态

        this.onFulfilledCallbacks = [] // 保存成功回调
        this.onRejectedCallbacks = [] // 保存失败回调
    }

    resolve(value) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行resolve，状态变为fulfilled
        this.PromiseState = 'fulfilled'
        // 终值为传进来的值
        this.PromiseResult = value
        // 执行保存的成功回调
        while (this.onFulfilledCallbacks.length) {
            this.onFulfilledCallbacks.shift()(this.PromiseResult)
        }
    }

    reject(reason) {
        // state是不可变的
        if (this.PromiseState !== 'pending') return
        // 如果执行reject，状态变为rejected
        this.PromiseState = 'rejected'
        // 终值为传进来的reason
        this.PromiseResult = reason
        // 执行保存的失败回调
        while (this.onRejectedCallbacks.length) {
            this.onRejectedCallbacks.shift()(this.PromiseResult)
        }
    }

    then(onFulfilled, onRejected) {
        // 接收两个回调 onFulfilled, onRejected

        // 参数校验，确保一定是函数
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val =&gt; val
        onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; { throw reason }

        var thenPromise = new MyPromise((resolve, reject) =&gt; {
            const resolvePromise = cb =&gt; {
                setTimeout(() =&gt; {
                    try {
                        const x = cb(this.PromiseResult)
                        if (x === thenPromise) {
                            throw new Error('不能返回自身')
                        }
                        if (x instanceof MyPromise) {
                            // 如果返回值是Promise
                            // 如果返回值是promise对象，返回值为成功，新promise就是成功
                            // 如果返回值是promise对象，返回值为失败，新promise就是失败
                            // 谁知道返回的promise是失败成功？只有then知道
                            x.then(resolve, reject)
                        } else {
                            // 非Promise就直接成功
                            resolve(x)
                        }
                    } catch (err) {
                        // 处理报错
                        reject(err)
                        throw new Error(err)
                    }
                })
            }

            if (this.PromiseState === 'fulfilled') {
                // 如果当前为成功状态，执行第一个回调
                resolvePromise(onFulfilled)
            } else if (this.PromiseState === 'rejected') {
                // 如果当前为失败状态，执行第二个回调
                resolvePromise(onRejected)
            } else if (this.PromiseState === 'pending') {
                // 如果状态为待定状态，暂时保存两个回调
                // 如果状态为待定状态，暂时保存两个回调
                this.onFulfilledCallbacks.push(resolvePromise.bind(this, onFulfilled))
                this.onRejectedCallbacks.push(resolvePromise.bind(this, onRejected))
            }
        })

        // 返回这个包装的Promise
        return thenPromise

    }
}
```
# race

特点：
- 接收一个Promise数组，数组中如有非Promise项，则此项当做成功
- 哪个Promise最快得到结果，就返回那个结果，无论成功失败
思路：
- 循环Promise数组，得到结果就resolve
```js
static race(promiseArr) {
    return new MyPromise((resolve, reject) =&gt; {
        promiseArr.forEach(promise =&gt; {
            if (promise instanceof MyPromise) {
                promise.then(res =&gt; {
                    resolve(res)
                }, err =&gt; {
                    reject(err)
                })
            } else {
                resolve(promise)
            }
        })
    })
}
```

# allSettled方法

allSettled会等待所有 Promise完成，并返回一个包含所有结果的对象数组
成功 fulfilled
失败 rejected

思路

- 入参：一个Promise数组 数组中如有非Promise项，则此项当做成功
- 返回值：一个 Promise集合成数组后返回 {status: '', value: ''}
- 实现：遍历数组，每个 Promise 执行 then 方法，将结果添加到数组中，最后返回数组

```js
static allSettled(promiseArr) {
    return new Promise((resolve, reject) =&gt; {
        const result = []
        let count = 0
        const addData = (status, value, i) =&gt; {
            result[i] = {
                status,
                value
            }
            count++
            if (count === promiseArr.length) {
                resolve(result)
            }
        }
        promiseArr.forEach((promise, i) =&gt; {
            if (promise instanceof MyPromise) {
                promise.then(res =&gt; {
                    addData('fulfilled', res, i)
                }, err =&gt; {
                    addData('rejected', err, i)
                })
            } else {
                addData('fulfilled', promise, i)
            }
        })
    })
}
```。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90-yi-bu-%E3%80%91-shou-xie-Promise.html</guid><pubDate>Fri, 10 Oct 2025 15:02:32 +0000</pubDate></item><item><title>【异步】JS 实现带并发的异步任务调度器</title><link>https://199yjy.github.io/record.github.io/post/%E3%80%90-yi-bu-%E3%80%91JS%20-shi-xian-dai-bing-fa-de-yi-bu-ren-wu-diao-du-qi.html</link><description># 【异步】JS 实现带并发的异步任务调度器
作用：控制异步任务的并发数量，避免因同时发起过多请求或任务导致服务器压力过大或系统资源耗尽，从而保证系统稳定性和性能。</description><guid isPermaLink="true">https://199yjy.github.io/record.github.io/post/%E3%80%90-yi-bu-%E3%80%91JS%20-shi-xian-dai-bing-fa-de-yi-bu-ren-wu-diao-du-qi.html</guid><pubDate>Fri, 03 Oct 2025 05:07:17 +0000</pubDate></item></channel></rss>