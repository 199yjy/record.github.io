核心机制：本质是 “一处登录，处处通行”。在多个相互信任的应用系统中，用户只需要登录一次，就可以访问所有系统，而无需重复输入用户名和密码。
关键点：
- 认证与授权分离：
认证：确认用户是谁。这个动作只在认证中心完成一次
授权：判断用户是否有权访问某个资源。各个业务应用负责授权，但它们不再负责认证
- 会话管理的变化
在没有SSO时，每个业务应用都维护自己的会话
在SSO架构下，业务应用不再管理用户的登录状态，它们只信任来自认证中心的凭证
- 令牌的流转
SSO的核心是安全地生成、传递和验证令牌
    - 检测本地是否已有有效令牌。
    - 如果没有，则重定向到认证中心。
    - 从URL参数或回调中获取认证中心下发的令牌。
    - 将令牌存储在安全的地方

实现方案：
单一域名：可以把 cookie 种在根域名下实现单点登录
多域名：常用 CAS（实现SSO单点登录的框架）来解决，新增一个认证中心的服务。

cas实现单点流程：
- 第⼀次访问系统A
    - ⽤⼾访问系统A跳转认证中⼼，然后输⼊⽤⼾名，密码登录，然后认证中⼼把cookieSSO 种在认证中⼼的域名下，重定向到系统A，并且带上⽣成的ticket参数 (?ticket=xxx)
    - 系统A(ticket=xxx)请求系统A的后端serverA，serverA去serverSSO验证，通过后 ，将cookieA种在系统A下
- 第⼆次访问系统A 直接携带 cookieA 去访问后端，验证通过后，即登录成功。
- 第三次访问系统B
    - 访问系统B，跳转到认证中⼼client，这个时候会把认证中⼼的cookieSSO也携带上，发现⽤户已登录过，则直接重定向到系统B，并且带上⽣成的ticket参数（?ticket=xxx）
- 系统B (?ticket =xxx)请求系统B的后端serverB ，serverB去serverSSO验证，通过后 ，将cookieB种在系统B下
- cookie⽣成时机及种的位置。
• cookieSSO ，SSO域名下的cookie
• cookieA ，系统A域名下的cookie
• cookieB，系统B域名下的cookie

流程：
认证服务：要一个专门的认证服务，用于处理用户的登录和认证
生成令牌：当用户进行登录操作时，认证服务会验证用户的凭证，并生成一个令牌。该令牌应包含用户的标识信息和其他必要的认证信息。
跨域存储令牌：在用户成功登录后，认证服务将令牌返回给前端应用。前端应用可以将该令牌存储在 LocalStorage 中。由于 LocalStorage 是浏览器独立于域名的存储机制，因此可以通过 LocalStorage实现跨域缓存。
发送令牌：当用户访问其他需要认证的前端应用时，前端应用会将存储在 LocalStorage 中的令牌附加在每个请求的请求头中发送给后端服务。
验证令牌：后端服务接收到请求后，会验证该请求中的令牌的有效性。验证令牌的过程包括检查令牌的签名、有效期、权限等信息。如果验证通过，后端服务会允许用户访问相应的资源。
单点登录：由于令牌是跨域存储的，因此当用户在一个前端应用中登录后，其他前端应用也可以通过 LocalStorage 中的令牌获取到用户的身份信息，从而实现单点登录的效果。

- 前端本地存储token
    - LocalStorage：HTML5提供的一种本地存储方案，LocalStorage中的数据会一直保留，除非主动清除或用户清除浏览器缓存
    - SessionStorage：与LocalStorage类似，也是HTML5提供的本地存储方案，但是数据的生命周期仅限于会话期间；当用户关闭浏览器标签页或浏览器时，SessionStorage中的数据会被清除
    - Cookie：在浏览器和服务器之间传递的小型数据片段，可以用于存储Token。浏览器会自动将Cookie作为请求头的一部分发送给服务器
    - IndexedDb：浏览器提供的一种高级的客户端存储数据库，可以用于存储大量结构化数据与LocalStorage和SessionStorage相比，异步执行，不会阻塞主线程，IndexedDB提供更丰富的查询和事务支持。存储Token时，需要使用IndexedDB的API进行操作，例如创建数据库、创建对象存储空间、存储Token数据等，适合存储离线数据。